#include "ctl.h"
#include "dev/debug/serial.h"
#include "entry/entry.h"
#include "irq/ctl/apic.h"
#include "irq/ctl/pic.h"
#include "libk/data/linkedlist.h"
#include "libk/flow/error.h"
#include "libk/string.h"
#include <mem/heap.h>
#include "mem/kmem_manager.h"
#include "sched/scheduler.h"
#include "system/acpi/acpi.h"
#include "system/acpi/parser.h"
#include "system/acpi/structures.h"
#include "system/processor/processor.h"
#include "system/processor/processor_info.h"

/*
 * Current IRQ controller code
 *
 * This shit reaks like shit
 * It is better than it was, but we'll need to remove any clutter from this part of the system and
 * create a framework that is concise, easy, and robust.
 *
 * There are several options for interrupt handling on an X86 system:
 *  - Legacy dual pic (programmable interrupt controller) by intel
 *    These are rarely physically present on a system, but ACPI tells us about the emulation capabilities
 *    of a given system. When we don't support any other controller that IS physically pressent on the system and
 *    the system also does NOT have PIC emulation, we bail.
 *
 *  - ACPI (Advanced programmable interrupt controller) also by intel
 *    This beast has narrow integration with ACPI (Thus why actual processor initialization is done after
 *    the ACPI subsystem in online). In order to get to know about it, we either need to ask our bootloader really
 *    nicely, but preferrably, we parse the MADT (Label: "APIC") table. This gives us the memory-mapped registers of 
 *    LAPICs, IOAPIC, and the BSP LAPIC. LAPIC are local to a give CPU core (And there is one available for the BSP, 
 *    which we use even when we aren't in SMP) and there is (or at least should be) a single IOAPIC that is embedded in
 *    the systems chipset. This badboy manages interrupts to all the LAPICs of the active cores. I'll give a lil more
 *    in-depth overview of both the LPICs and the IOAPIC
 * 
 * LAPIC: as mentioned, this puppy is local to a given CPU core and it thus manages the interrupts that are also local to 
 * this core. It houses the LVT, which is a redirection table for interrupt vectors (When doing IRQ allocation, this table
 * is of importance). LVT maps interrupts that are generated by the CPU and LAPIC themselves. The LAPIC also contains space 
 * to send interrupts to different CPUs
 * 
 * IOAPIC: This chip isn't part of the CPU and is instead responsable for managing external interrupts from and to different 
 * CPU cores. Things like PCI interrupt vectors, or the keyboard interrupt can all be mapped with this chip. To do this, it
 * contains the interrupt redirection table (IRT). This table contains 24 64-bit wide entries that tell us all kinds of neat
 * things about a give interrupt vector. Note that the IDT has room for 255 entries, so there are a total of 255 possible interrupt
 * vectors that can be allocated. Combining this with the fact that there are (Per IOAPIC) 24 external interrupt pins, there is 
 * a lot of room left on the IDT, but that's okay. This is because a system does not need more than 24 external pins (Most of the
 * time). The intel IOAPIC (I82093AA) datasheet gives an overview of which external IRQs are oftern connected to these pins
 *                      _____________________________
 *                      |                           |- Allocated IRQ in the IDT
 *  External interrupt  |                           |-------------------->
 *  (keyboard, rdte 1)  |          IO APIC          |-
 *  ------------------->|                           |-
 *                      |___________________________|
 * 
 * The external : IRQ mapping might not be one to one. As a driver discovers a certain device, which reports that it uses a certain
 * interrupt pin/line, we need to make sure that that the handler that driver registers also gets called when the interrupt occurs.
 * this is the reason we need to keep track of IRQ allocations, and map the IOAPIC accordingly.
 * 
 * NOTE: IDT entry 0x00 to 0x1F are allocated for system exceptions, so redirecting ACPI pins to any of those vectors should NEVER
 * happen. Otherwise the system might think we triggered a pagefault, when we really where just pressing a keyboard key LMAOOO
 */                     

/* Most likely a DUAL PIC */
static irq_chip_t* _c_active;

/*!
 * @brief: Initialize the interrupt chips
 *
 * Done after ACPI and IDT where initialized and during the late 
 * processor initialization
 *
 * Currently this only initializes a DUAL PIC controller
 */
void init_intr_ctl()
{
  _c_active = get_pic();

  irq_chip_enable(_c_active);

}

#define VERIFY_CHIP(chip, chip_op)   \
  do {                      \
    if (!(chip) || !(chip)->ops) \
      return -1;                    \
    if (!(chip)->ops->chip_op)     \
      return -2;                    \
  } while (0)

int irq_chip_ack(irq_chip_t* chip, struct irq* irq)
{
  VERIFY_CHIP(chip, ictl_eoi);

  if (!irq)
    return -3;

  chip->ops->ictl_eoi(chip, irq->vec);
  return 0;
}

int irq_chip_enable(irq_chip_t* chip)
{
  VERIFY_CHIP(chip, ictl_enable);

  chip->ops->ictl_enable(chip);
  return 0;
}

int irq_chip_disable(irq_chip_t* chip)
{
  VERIFY_CHIP(chip, ictl_disable);

  chip->ops->ictl_disable(chip);
  return 0;
}

int irq_chip_mask(irq_chip_t* chip, uint32_t vec)
{
  VERIFY_CHIP(chip, f_mask_vec);

  return chip->ops->f_mask_vec(chip, vec);
}

int irq_chip_unmask(irq_chip_t* chip, uint32_t vec)
{
  VERIFY_CHIP(chip, f_unmask_vec);

  return chip->ops->f_unmask_vec(chip, vec);
}

int irq_chip_mask_all(irq_chip_t* chip)
{
  VERIFY_CHIP(chip, f_mask_all);

  return chip->ops->f_mask_all(chip);
}
