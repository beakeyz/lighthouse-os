#include "ctl.h"
#include "dev/debug/serial.h"
#include "entry/entry.h"
#include "irq/ctl/apic.h"
#include "irq/ctl/pic.h"
#include "libk/data/linkedlist.h"
#include "libk/string.h"
#include <mem/heap.h>
#include "mem/kmem_manager.h"
#include "sched/scheduler.h"
#include "system/acpi/acpi.h"
#include "system/acpi/parser.h"
#include "system/acpi/structures.h"
#include "system/processor/processor.h"
#include "system/processor/processor_info.h"

/*
 * Current IRQ controller code
 *
 * This shit reaks like shit
 * It is better than it was, but we'll need to remove any clutter from this part of the system and
 * create a framework that is concise, easy, and robust.
 *
 * There are several options for interrupt handling on an X86 system:
 *  - Legacy dual pic (programmable interrupt controller) by intel
 *    These are rarely physically present on a system, but ACPI tells us about the emulation capabilities
 *    of a given system. When we don't support any other controller that IS physically pressent on the system and
 *    the system also does NOT have PIC emulation, we bail.
 *
 *  - ACPI (Advanced programmable interrupt controller) also by intel
 *    This beast has narrow integration with ACPI (Thus why actual processor initialization is done after
 *    the ACPI subsystem in online). In order to get to know about it, we either need to ask our bootloader really
 *    nicely, but preferrably, we parse the MADT (Label: "APIC") table. This gives us the memory-mapped registers of 
 *    LAPICs, IOAPIC, and the BSP LAPIC. LAPIC are local to a give CPU core (And there is one available for the BSP, 
 *    which we use even when we aren't in SMP) and there is (or at least should be) a single IOAPIC that is embedded in
 *    the systems chipset. This badboy manages interrupts to all the LAPICs of the active cores. I'll give a lil more
 *    in-depth overview of both the LPICs and the IOAPIC
 * 
 * LAPIC: as mentioned, this puppy is local to a given CPU core and it thus manages the interrupts that are also local to 
 * this core. It houses the LVT, which is a redirection table for interrupt vectors (When doing IRQ allocation, this table
 * is of importance). LVT maps interrupts that are generated by the CPU and LAPIC themselves. The LAPIC also contains space 
 * to send interrupts to different CPUs
 * 
 * IOAPIC: This chip isn't part of the CPU and is instead responsable for managing external interrupts from and to different 
 * CPU cores. Things like PCI interrupt vectors, or the keyboard interrupt can all be mapped with this chip. To do this, it
 * contains the interrupt redirection table (IRT). This table contains 24 64-bit wide entries that tell us all kinds of neat
 * things about a give interrupt vector. Note that the IDT has room for 255 entries, so there are a total of 255 possible interrupt
 * vectors that can be allocated. Combining this with the fact that there are (Per IOAPIC) 24 external interrupt pins, there is 
 * a lot of room left on the IDT, but that's okay. This is because a system does not need more than 24 external pins (Most of the
 * time). The intel IOAPIC (I82093AA) datasheet gives an overview of which external IRQs are oftern connected to these pins
 *                      _____________________________
 *                      |                           |- Allocated IRQ in the IDT
 *  External interrupt  |                           |-------------------->
 *  (keyboard, rdte 1)  |          IO APIC          |-
 *  ------------------->|                           |-
 *                      |___________________________|
 * 
 * The external : IRQ mapping might not be one to one. As a driver discovers a certain device, which reports that it uses a certain
 * interrupt pin/line, we need to make sure that that the handler that driver registers also gets called when the interrupt occurs.
 * this is the reason we need to keep track of IRQ allocations, and map the IOAPIC accordingly.
 * 
 * NOTE: IDT entry 0x00 to 0x1F are allocated for system exceptions, so redirecting ACPI pins to any of those vectors should NEVER
 * happen. Otherwise the system might think we triggered a pagefault, when we really where just pressing a keyboard key LMAOOO
 */                     

static uint32_t lapic_address;

/* Most likely a DUAL PIC */
static int_controller_t* fallback;

static void mark_ctl_failure()
{
  g_system_info.sys_flags |= SYSFLAGS_NO_INTERRUPTS;
}

/*!
 * @brief Make sure all the vectors on the fallback controller are masked
 *
 * Nothing to add here...
 */
static void fallback_mask_all()
{
  if (!fallback)
    return;

  /* Mask all the vectors, NOTE: both PICs are capable of 8 irqs */
  for (uint32_t i = 0; i < 16; i++) {
    fallback->ictl_disable_vec(i);
  }
}

/*!
 * @brief Initialize a fallback dual PIC interrupt controller
 *
 * Nothing to add here...
 */
static void initialize_fallback_controller()
{
  fallback = get_pic();

  /* Enable the fallback controller */
  fallback->ictl_enable(fallback);

  fallback_mask_all();
}

/*!
 * @brief Remove the fallback controller
 *
 * If an advanced interrupt management chip can handle coverage of the entire interrupt range, we can 
 * (and should) remove and disable the fallback controller, since it can only fuck us over at that point
 */
static void remove_fallback_controller()
{
  /* Mask all the vectors, to be sure */
  fallback_mask_all();

  /* Disable the controller */
  fallback->ictl_disable(fallback);

  /* Remove the controller */
  fallback = nullptr;
}

static void reset_fallback_controller()
{
  fallback = get_pic();

  /* Enable, just in case */
  fallback->ictl_enable(fallback);

  /* Remove it again */
  remove_fallback_controller();
}

static inline bool has_fallback()
{
  return (fallback != nullptr);
}

void init_intr_ctl()
{
  int error;
  acpi_parser_t* parser;
  struct acpi_table_madt* madt;

  fallback = NULL;
  lapic_address = NULL;

  /* NOTE: this never fails */
  get_root_acpi_parser(&parser);

  madt = acpi_parser_find_table(parser, MADT_SIGNATURE, sizeof(struct acpi_table_madt));

  /* No MADT? That's just fatal lmao */
  if (!madt)
    goto no_valid_ctl;

  /* Completely disable the fallback controller early, so we can at least have that, if our machine does not have a APIC fsr lmao */
  if ((madt->flags & ACPI_MADT_PCAT_COMPAT) == ACPI_MADT_DUAL_PIC)
    reset_fallback_controller();

  /* Yay, we have a local apic for the bsp! */
  lapic_address = madt->address;

  error = init_bsp_apic(madt, lapic_address);

  /* If something went wrong while setting up the bsp lapic and IO apics, revert to fallback */
  if (error && (madt->flags & ACPI_MADT_PCAT_COMPAT) == ACPI_MADT_DUAL_PIC)
    initialize_fallback_controller();

  return;
no_valid_ctl:
  mark_ctl_failure();
}

/*!
 * @brief Get the active controller for a certain interrupt vector
 *
 * When the fallback controller is active and manages this vector, we'll use that.
 * otherwise, we'll look for APIC stuff
 */
int_controller_t *get_controller_for_int_number(uint16_t vector) 
{
  if (has_fallback() && vector < 16)
    return fallback;

  /* TODO: */
  return nullptr;
}
