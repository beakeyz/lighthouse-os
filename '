#include "scheduler.h"
#include "dev/debug/serial.h"
#include "kmain.h"
#include "libk/error.h"
#include "libk/linkedlist.h"
#include "libk/stddef.h"
#include "proc/proc.h"
#include "proc/thread.h"

static list_t* s_thread_list = nullptr;

static void test_kernel_thread_func () {
  for (;;) {}
}

LIGHT_STATUS init_scheduler() {
  s_thread_list = init_list();

  proc_t* proc_ptr = create_kernel_proc(test_kernel_thread_func);

  ASSERT(proc_ptr != nullptr);
  ASSERT(proc_ptr->m_id == 0);

  thread_t* thread = list_get(proc_ptr->m_threads, 0);

  // Make sure we are runnable
  thread->m_current_state = RUNNABLE;

  list_append(g_GlobalSystemInfo.m_current_core->m_processes, proc_ptr);

  return LIGHT_FAIL;
}

void enter_scheduler() {

  Processor_t* current = g_GlobalSystemInfo.m_current_core;
  proc_t* proc_ptr = list_get(current->m_processes, 0);

  ASSERT(proc_ptr != nullptr);
  ASSERT(proc_ptr->m_id == 0);

  thread_t* thread = list_get(proc_ptr->m_threads, 0);

  LIGHT_STATUS result = thread_prepare_context(thread);

  if (result == LIGHT_SUCCESS) {
    thread->m_current_state = RUNNING;
  }

  switch_context_to(thread);

  kernel_panic("RETURNED FROM enter_scheduler!");
} 

LIGHT_STATUS exit_scheduler() {

  return LIGHT_FAIL;
}

LIGHT_STATUS switch_context_to(thread_t* thread) {
  
  if (thread->m_current_state != RUNNABLE) {
    return LIGHT_FAIL;
  }

  kContext_t context = thread->m_context;
  Processor_t* current = g_GlobalSystemInfo.m_current_core;

  // TODO:
  current->m_tss.iomap_base = sizeof(current->m_tss);
  current->m_tss.rsp[0] = context.rsp0 & 0xffffffff;
  current->m_tss.rsp[1] = context.rsp0 >> 32;


  // asm jumppoint
  asm volatile (
    "movq %[rsp], %%rsp \n"
    "pushq %[thread] \n"
    "pushq %[thread] \n"
    "pushq %[rip] \n"
    "cld \n"
    "movq 24(%%rsp), %%rdi \n"
    "call %[test_regs] \n"
    "retq \n"
    ::  [rsp] "g" (context.rsp),
        [rip] "a" (context.rip),
        [thread] "b" (thread),
        [test_regs] "c"(test_kernel_thread_func)
  );

  return LIGHT_FAIL;
}

void sched_tick(registers_t*);

thread_t* next_thread();
proc_t* next_proc();

LIGHT_STATUS sched_add_proc(proc_t*, proc_id);
LIGHT_STATUS sched_add_thead(thread_t*);

LIGHT_STATUS sched_remove_proc(proc_t*);
LIGHT_STATUS sched_remove_proc_by_id(proc_id);
LIGHT_STATUS sched_remove_thread(thread_t*);

