/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const NULL: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const Kib: u32 = 1024;
pub const Mib: u32 = 1048576;
pub const Gib: u32 = 1073741824;
pub const Tib: u64 = 1099511627776;
pub const LOGGER_MAX_COUNT: u32 = 255;
pub const LOGGER_FLAG_DEBUG: u32 = 1;
pub const LOGGER_FLAG_INFO: u32 = 2;
pub const LOGGER_FLAG_WARNINGS: u32 = 4;
pub const LOGGER_FLAG_NO_PREFIX: u32 = 8;
pub const LOG_TYPE_DEFAULT: u32 = 0;
pub const LOG_TYPE_LINE: u32 = 1;
pub const LOG_TYPE_CHAR: u32 = 2;
pub const KERR_FATAL_BIT: u32 = 2147483648;
pub const KERR_NONE: u32 = 0;
pub const KERR_INVAL: u32 = 1;
pub const KERR_IO: u32 = 2;
pub const KERR_NOMEM: u32 = 3;
pub const KERR_MEM: u32 = 4;
pub const KERR_NODEV: u32 = 5;
pub const KERR_DEV: u32 = 6;
pub const KERR_NODRV: u32 = 7;
pub const KERR_DRV: u32 = 8;
pub const KERR_NOCON: u32 = 9;
pub const KERR_NOT_FOUND: u32 = 10;
pub const KERR_SIZE_MISMATCH: u32 = 11;
pub const KERR_NULL: u32 = 12;
pub const KERR_DUPLICATE: u32 = 13;
pub const EOP_ERROR: u32 = 0;
pub const EOP_NOMEM: u32 = 1;
pub const EOP_INVAL: u32 = 2;
pub const EOP_BUSY: u32 = 3;
pub const EOP_NODEV: u32 = 4;
pub const EOP_NOCON: u32 = 5;
pub const EOP_NULL: u32 = 6;
pub const DRIVER_URL_SEPERATOR: u8 = 47u8;
pub const DRIVER_TYPE_COUNT: u32 = 9;
pub const DRIVER_MAX_DEV_COUNT: u32 = 64;
pub const DT_DISK: u32 = 0;
pub const DT_FS: u32 = 1;
pub const DT_IO: u32 = 2;
pub const DT_SOUND: u32 = 3;
pub const DT_GRAPHICS: u32 = 4;
pub const DT_SERVICE: u32 = 5;
pub const DT_DIAGNOSTICS: u32 = 6;
pub const DT_OTHER: u32 = 7;
pub const DT_FIRMWARE: u32 = 8;
pub const DRV_INFINITE: u32 = 4294967295;
pub const DRV_SERVICE_MAX: u32 = 256;
pub const drv_manifest_SOFTMAX: u32 = 512;
pub const MAX_DRIVER_NAME_LENGTH: u32 = 128;
pub const MAX_DRIVER_DESCRIPTOR_LENGTH: u32 = 64;
pub const EXPSYM_SHDR_NAME: &[u8; 8] = b".expsym\0";
pub const NO_MANIFEST: u32 = 0;
pub const DRVDEP_FLAG_RELPATH: u32 = 1;
pub const DRVDEP_FLAG_OPTIONAL: u32 = 2;
pub const DRV_FS: u32 = 1;
pub const DRV_NON_ESSENTIAL: u32 = 2;
pub const DRV_ACTIVE: u32 = 4;
pub const DRV_ALLOW_DYNAMIC_LOADING: u32 = 8;
pub const DRV_HAS_HANDLE: u32 = 16;
pub const DRV_FAILED: u32 = 32;
pub const DRV_DEFERRED: u32 = 64;
pub const DRV_LIMIT_REACHED: u32 = 128;
pub const DRV_WANT_PROC: u32 = 256;
pub const DRV_HAD_DEP: u32 = 512;
pub const DRV_SYSTEM: u32 = 1024;
pub const DRV_ORPHAN: u32 = 2048;
pub const DRV_IS_EXTERNAL: u32 = 4096;
pub const DRV_HAS_MSG_FUNC: u32 = 8192;
pub const DRV_DEFERRED_HNDL: u32 = 16384;
pub const DRV_CORE: u32 = 32768;
pub const DRV_LOADED: u32 = 65536;
pub const DRV_STAT_OK: u32 = 0;
pub const DRV_STAT_INVAL: i32 = -1;
pub const DRV_STAT_NOMAN: i32 = -2;
pub const DRV_STAT_BUSY: i32 = -3;
pub const PDE_PRESENT: u32 = 1;
pub const PDE_WRITABLE: u32 = 2;
pub const PDE_USER: u32 = 4;
pub const PDE_WRITE_THROUGH: u32 = 8;
pub const PDE_NO_CACHE: u32 = 16;
pub const PDE_ACCESSED: u32 = 32;
pub const PDE_DIRTY: u32 = 64;
pub const PDE_HUGE_PAGE: u32 = 128;
pub const PDE_GLOBAL: u32 = 256;
pub const PDE_NX: i64 = -9223372036854775808;
pub const PTE_PRESENT: u32 = 1;
pub const PTE_WRITABLE: u32 = 2;
pub const PTE_USER: u32 = 4;
pub const PTE_WRITE_THROUGH: u32 = 8;
pub const PTE_NO_CACHE: u32 = 16;
pub const PTE_ACCESSED: u32 = 32;
pub const PTE_DIRTY: u32 = 64;
pub const PTE_PAT: u32 = 128;
pub const PTE_GLOBAL: u32 = 256;
pub const PTE_NX: i64 = -9223372036854775808;
pub const MALLOC_NODE_FLAG_USED: u32 = 1;
pub const MALLOC_NODE_FLAG_PARITY: u32 = 2;
pub const MALLOC_NODE_FLAG_READONLY: u32 = 4;
pub const MALLOC_NODE_FLAGS_MASK: u32 = 7;
pub const MALLOC_NODE_SIZE_MASK: i32 = -8;
pub const GHEAP_READONLY: u32 = 1;
pub const GHEAP_KERNEL: u32 = 2;
pub const GHEAP_EXPANDABLE: u32 = 4;
pub const GHEAP_ZEROED: u32 = 8;
pub const GHEAP_NOBLOCK: u32 = 16;
pub type uint_t = ::std::os::raw::c_uint;
pub type bool_ = u8;
pub type vaddr_t = usize;
pub type paddr_t = usize;
pub type va_list = __builtin_va_list;
pub type FuncPtr = ::std::option::Option<unsafe extern "C" fn()>;
pub type logger_id_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct logger_t {
    pub title: *mut ::std::os::raw::c_char,
    pub flags: u8,
    pub id: logger_id_t,
    pub f_logc: ::std::option::Option<
        unsafe extern "C" fn(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    pub f_log: ::std::option::Option<
        unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    pub f_logln: ::std::option::Option<
        unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_logger_t() {
    const UNINIT: ::std::mem::MaybeUninit<logger_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<logger_t>(),
        40usize,
        concat!("Size of: ", stringify!(logger_t))
    );
    assert_eq!(
        ::std::mem::align_of::<logger_t>(),
        8usize,
        concat!("Alignment of ", stringify!(logger_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(logger_t),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(logger_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(logger_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_logc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(logger_t),
            "::",
            stringify!(f_logc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_log) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(logger_t),
            "::",
            stringify!(f_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_logln) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(logger_t),
            "::",
            stringify!(f_logln)
        )
    );
}
extern "C" {
    pub fn init_early_logging();
}
extern "C" {
    pub fn init_logging();
}
extern "C" {
    pub fn register_logger(logger: *mut logger_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_logger(logger: *mut logger_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn logger_get(id: logger_id_t, buffer: *mut logger_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn logger_scan(
        title: *mut ::std::os::raw::c_char,
        buffer: *mut logger_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn logger_swap_priority(old: logger_id_t, new: logger_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn log(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn logf(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vlogf(fmt: *const ::std::os::raw::c_char, args: *mut __va_list_tag);
}
extern "C" {
    pub fn logln(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn log_ex(
        id: logger_id_t,
        msg: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
        type_: u8,
    );
}
extern "C" {
    pub fn sfmt(
        buf: *mut ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kputch(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print(msg: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn println(msg: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}

extern "C" {
    pub fn vprintf(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kdbgf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vkdbgf(
        prefix: bool_,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kdbgln(msg: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kdbg(msg: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kdbgc(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kwarnf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kwarnln(msg: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kwarn(msg: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kwarnc(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type kerror_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kerror_frame {
    pub code: kerror_t,
    pub ctx: *const ::std::os::raw::c_char,
    pub prev: *mut kerror_frame,
}
#[test]
fn bindgen_test_layout_kerror_frame() {
    const UNINIT: ::std::mem::MaybeUninit<kerror_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kerror_frame>(),
        24usize,
        concat!("Size of: ", stringify!(kerror_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<kerror_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(kerror_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kerror_frame),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kerror_frame),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kerror_frame),
            "::",
            stringify!(prev)
        )
    );
}
pub type kerror_frame_t = kerror_frame;
extern "C" {
    pub fn init_kerror();
}
extern "C" {
    pub fn push_kerror(err: kerror_t, ctx: *const ::std::os::raw::c_char) -> kerror_t;
}
extern "C" {
    pub fn pop_kerror(frame: *mut kerror_frame_t) -> kerror_t;
}
extern "C" {
    pub fn drain_kerrors();
}
pub const _ANIVA_STATUS_ANIVA_FAIL: _ANIVA_STATUS = 0;
pub const _ANIVA_STATUS_ANIVA_WARNING: _ANIVA_STATUS = 1;
pub const _ANIVA_STATUS_ANIVA_SUCCESS: _ANIVA_STATUS = 2;
pub const _ANIVA_STATUS_ANIVA_NOMEM: _ANIVA_STATUS = 3;
pub const _ANIVA_STATUS_ANIVA_NODEV: _ANIVA_STATUS = 4;
pub const _ANIVA_STATUS_ANIVA_NOCONN: _ANIVA_STATUS = 5;
pub const _ANIVA_STATUS_ANIVA_FULL: _ANIVA_STATUS = 6;
pub const _ANIVA_STATUS_ANIVA_EMPTY: _ANIVA_STATUS = 7;
pub const _ANIVA_STATUS_ANIVA_BUSY: _ANIVA_STATUS = 8;
pub const _ANIVA_STATUS_ANIVA_INVAL: _ANIVA_STATUS = 9;
pub type _ANIVA_STATUS = ::std::os::raw::c_uint;
pub use self::_ANIVA_STATUS as ANIVA_STATUS;
extern "C" {
    pub fn __kernel_panic() -> !;
}
extern "C" {
    pub fn kernel_panic(panic_message: *const ::std::os::raw::c_char) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oss_obj {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oss_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drv_manifest {
    _unused: [u8; 0],
}
pub type dev_type_t = u8;
pub const dev_flags_STANDARD: dev_flags = 1;
pub const dev_flags_FROM_FILE: dev_flags = 2;
pub const dev_flags_LOADED_WITH_WARNING: dev_flags = 4;
pub type dev_flags = ::std::os::raw::c_uint;
pub use self::dev_flags as DEV_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_constraint {
    pub max_active: u32,
    pub current_active: u32,
    pub max_count: u32,
    pub current_count: u32,
    pub type_: dev_type_t,
    pub res0: u8,
    pub res1: u16,
    pub res2: u32,
    pub active: *mut drv_manifest,
    pub core: *mut drv_manifest,
}
#[test]
fn bindgen_test_layout_dev_constraint() {
    const UNINIT: ::std::mem::MaybeUninit<dev_constraint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dev_constraint>(),
        40usize,
        concat!("Size of: ", stringify!(dev_constraint))
    );
    assert_eq!(
        ::std::mem::align_of::<dev_constraint>(),
        8usize,
        concat!("Alignment of ", stringify!(dev_constraint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_active) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(max_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_active) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(current_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(max_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(current_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res0) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(res0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res1) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(res1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(res2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dev_constraint),
            "::",
            stringify!(core)
        )
    );
}
pub type dev_constraint_t = dev_constraint;
extern "C" {
    pub static mut dev_type_urls: [*const ::std::os::raw::c_char; 9usize];
}
pub type dev_url_t = *const ::std::os::raw::c_char;
pub type driver_control_code_t = u32;
pub type dcc_t = driver_control_code_t;
extern "C" {
    pub fn init_aniva_driver_registry();
}
extern "C" {
    pub fn init_driver_subsys();
}
extern "C" {
    pub fn allocate_dmanifest() -> *mut drv_manifest;
}
extern "C" {
    pub fn free_dmanifest(manifest: *mut drv_manifest);
}
extern "C" {
    pub fn install_driver(driver: *mut drv_manifest) -> kerror_t;
}
extern "C" {
    pub fn uninstall_driver(handle: *mut drv_manifest) -> kerror_t;
}
extern "C" {
    pub fn load_driver(manifest: *mut drv_manifest) -> kerror_t;
}
extern "C" {
    pub fn unload_driver(url: dev_url_t) -> kerror_t;
}
extern "C" {
    pub fn is_driver_installed(handle: *mut drv_manifest) -> bool_;
}
extern "C" {
    pub fn is_driver_loaded(handle: *mut drv_manifest) -> bool_;
}
extern "C" {
    pub fn get_driver(url: dev_url_t) -> *mut drv_manifest;
}
extern "C" {
    pub fn get_main_driver_from_type(type_: dev_type_t) -> *mut drv_manifest;
}
extern "C" {
    pub fn get_driver_from_type(type_: dev_type_t, index: u32) -> *mut drv_manifest;
}
extern "C" {
    pub fn get_core_driver(type_: dev_type_t) -> *mut drv_manifest;
}
extern "C" {
    pub fn get_main_driver_path(
        buffer: *mut ::std::os::raw::c_char,
        type_: dev_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_driver_type_count(type_: dev_type_t) -> usize;
}
extern "C" {
    pub fn foreach_driver(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                h: *mut oss_node,
                obj: *mut oss_obj,
                arg: *mut ::std::os::raw::c_void,
            ) -> bool_,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> kerror_t;
}
extern "C" {
    pub fn set_main_driver(dev: *mut drv_manifest, type_: dev_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn verify_driver(manifest: *mut drv_manifest) -> bool_;
}
extern "C" {
    pub fn replace_main_driver(manifest: *mut drv_manifest, uninstall: bool_);
}
extern "C" {
    pub fn register_core_driver(
        driver: *mut aniva_driver,
        type_: dev_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_core_driver(driver: *mut aniva_driver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn try_driver_get(driver: *mut aniva_driver, flags: u32) -> *mut drv_manifest;
}
extern "C" {
    pub fn driver_set_ready(path: *const ::std::os::raw::c_char) -> kerror_t;
}
extern "C" {
    pub fn driver_get_type_str(driver: *mut drv_manifest) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn driver_send_msg(
        path: *const ::std::os::raw::c_char,
        code: driver_control_code_t,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: usize,
    ) -> kerror_t;
}
extern "C" {
    pub fn driver_send_msg_a(
        path: *const ::std::os::raw::c_char,
        code: driver_control_code_t,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: usize,
        resp_buffer: *mut ::std::os::raw::c_void,
        resp_buffer_size: usize,
    ) -> kerror_t;
}
extern "C" {
    pub fn driver_send_msg_ex(
        driver: *mut drv_manifest,
        code: driver_control_code_t,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: usize,
        resp_buffer: *mut ::std::os::raw::c_void,
        resp_buffer_size: usize,
    ) -> kerror_t;
}
extern "C" {
    pub fn driver_send_msg_sync(
        path: *const ::std::os::raw::c_char,
        code: driver_control_code_t,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: usize,
    ) -> kerror_t;
}
extern "C" {
    pub fn driver_map(
        driver: *mut drv_manifest,
        base: *mut ::std::os::raw::c_void,
        size: usize,
        page_flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn driver_unmap(
        driver: *mut drv_manifest,
        base: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn driver_allocate(
        driver: *mut drv_manifest,
        size: usize,
        page_flags: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn driver_deallocate(
        driver: *mut drv_manifest,
        base: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn driver_kmalloc(driver: *mut drv_manifest, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn driver_kfree(
        driver: *mut drv_manifest,
        arg1: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn driver_send_msg_sync_with_timeout(
        path: *const ::std::os::raw::c_char,
        code: driver_control_code_t,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: usize,
        mto: usize,
    ) -> kerror_t;
}
extern "C" {
    pub fn get_driver_url(handle: *mut aniva_driver) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_driver_url_length(handle: *mut aniva_driver) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union driver_version {
    pub __bindgen_anon_1: driver_version__bindgen_ty_1,
    pub version: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct driver_version__bindgen_ty_1 {
    pub maj: u8,
    pub min: u8,
    pub bump: u16,
}
#[test]
fn bindgen_test_layout_driver_version__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<driver_version__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<driver_version__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(driver_version__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<driver_version__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(driver_version__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(driver_version__bindgen_ty_1),
            "::",
            stringify!(maj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(driver_version__bindgen_ty_1),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bump) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(driver_version__bindgen_ty_1),
            "::",
            stringify!(bump)
        )
    );
}
#[test]
fn bindgen_test_layout_driver_version() {
    const UNINIT: ::std::mem::MaybeUninit<driver_version> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<driver_version>(),
        4usize,
        concat!("Size of: ", stringify!(driver_version))
    );
    assert_eq!(
        ::std::mem::align_of::<driver_version>(),
        4usize,
        concat!("Alignment of ", stringify!(driver_version))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(driver_version),
            "::",
            stringify!(version)
        )
    );
}
pub type driver_version_t = driver_version;
pub const DRV_DEPTYPE_DRV_DEPTYPE_URL: DRV_DEPTYPE = 0;
pub const DRV_DEPTYPE_DRV_DEPTYPE_PATH: DRV_DEPTYPE = 1;
pub const DRV_DEPTYPE_DRV_DEPTYPE_PROC: DRV_DEPTYPE = 2;
pub type DRV_DEPTYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drv_dependency {
    pub type_: DRV_DEPTYPE,
    pub flags: u32,
    pub location: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_drv_dependency() {
    const UNINIT: ::std::mem::MaybeUninit<drv_dependency> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drv_dependency>(),
        16usize,
        concat!("Size of: ", stringify!(drv_dependency))
    );
    assert_eq!(
        ::std::mem::align_of::<drv_dependency>(),
        8usize,
        concat!("Alignment of ", stringify!(drv_dependency))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drv_dependency),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drv_dependency),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drv_dependency),
            "::",
            stringify!(location)
        )
    );
}
pub type drv_dependency_t = drv_dependency;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aniva_driver {
    pub m_name: [::std::os::raw::c_char; 128usize],
    pub m_descriptor: [::std::os::raw::c_char; 64usize],
    pub m_version: driver_version_t,
    pub m_type: dev_type_t,
    pub f_init: ::std::option::Option<
        unsafe extern "C" fn(this: *mut drv_manifest) -> ::std::os::raw::c_int,
    >,
    pub f_exit: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub f_msg: ::std::option::Option<
        unsafe extern "C" fn(
            driver: *mut aniva_driver,
            code: driver_control_code_t,
            buffer: *mut ::std::os::raw::c_void,
            size: usize,
            out_buffer: *mut ::std::os::raw::c_void,
            out_size: usize,
        ) -> usize,
    >,
    pub f_probe: ::std::option::Option<
        unsafe extern "C" fn(
            driver: *mut aniva_driver,
            device: *mut device,
        ) -> ::std::os::raw::c_int,
    >,
    pub m_deps: *mut drv_dependency,
}
#[test]
fn bindgen_test_layout_aniva_driver() {
    const UNINIT: ::std::mem::MaybeUninit<aniva_driver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aniva_driver>(),
        240usize,
        concat!("Size of: ", stringify!(aniva_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<aniva_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(aniva_driver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_descriptor) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(m_descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_version) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(m_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(m_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_init) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(f_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_exit) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(f_exit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_msg) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(f_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_probe) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(f_probe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_deps) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(aniva_driver),
            "::",
            stringify!(m_deps)
        )
    );
}
pub type aniva_driver_t = aniva_driver;
extern "C" {
    pub fn driver_is_ready(manifest: *mut drv_manifest) -> bool_;
}
extern "C" {
    pub fn driver_is_busy(manifest: *mut drv_manifest) -> bool_;
}
extern "C" {
    pub fn drv_read(
        manifest: *mut drv_manifest,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: *mut usize,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drv_write(
        manifest: *mut drv_manifest,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: *mut usize,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn driver_takeover_device(
        manifest: *mut drv_manifest,
        device: *mut device,
        newname: *const ::std::os::raw::c_char,
        newgroup: *mut dgroup,
        dev_priv: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bootstrap_driver(manifest: *mut drv_manifest) -> kerror_t;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union pml_entry {
    pub raw_bits: u64,
}
#[test]
fn bindgen_test_layout_pml_entry() {
    const UNINIT: ::std::mem::MaybeUninit<pml_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pml_entry>(),
        8usize,
        concat!("Size of: ", stringify!(pml_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<pml_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(pml_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pml_entry),
            "::",
            stringify!(raw_bits)
        )
    );
}
pub type pml_entry_t = pml_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_dir_t {
    pub m_kernel_high: vaddr_t,
    pub m_kernel_low: vaddr_t,
    pub m_root: *mut pml_entry_t,
    pub m_phys_root: paddr_t,
}
#[test]
fn bindgen_test_layout_page_dir_t() {
    const UNINIT: ::std::mem::MaybeUninit<page_dir_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<page_dir_t>(),
        32usize,
        concat!("Size of: ", stringify!(page_dir_t))
    );
    assert_eq!(
        ::std::mem::align_of::<page_dir_t>(),
        8usize,
        concat!("Alignment of ", stringify!(page_dir_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_kernel_high) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page_dir_t),
            "::",
            stringify!(m_kernel_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_kernel_low) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page_dir_t),
            "::",
            stringify!(m_kernel_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_root) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page_dir_t),
            "::",
            stringify!(m_root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_phys_root) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(page_dir_t),
            "::",
            stringify!(m_phys_root)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct heap_node {
    pub attr: usize,
    pub next: *mut heap_node,
    pub prev: *mut heap_node,
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_heap_node() {
    const UNINIT: ::std::mem::MaybeUninit<heap_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heap_node>(),
        24usize,
        concat!("Size of: ", stringify!(heap_node))
    );
    assert_eq!(
        ::std::mem::align_of::<heap_node>(),
        8usize,
        concat!("Alignment of ", stringify!(heap_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_node),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_node),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_node),
            "::",
            stringify!(data)
        )
    );
}
pub type heap_node_t = heap_node;
#[repr(C)]
#[derive(Debug)]
pub struct heap_node_buffer {
    pub m_node_count: usize,
    pub m_buffer_size: usize,
    pub m_next: *mut heap_node_buffer,
    pub m_start_node: __IncompleteArrayField<heap_node_t>,
}
#[test]
fn bindgen_test_layout_heap_node_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<heap_node_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heap_node_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(heap_node_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<heap_node_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(heap_node_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_node_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_node_buffer),
            "::",
            stringify!(m_node_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_node_buffer),
            "::",
            stringify!(m_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_node_buffer),
            "::",
            stringify!(m_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_start_node) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_node_buffer),
            "::",
            stringify!(m_start_node)
        )
    );
}
pub type heap_node_buffer_t = heap_node_buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memory_allocator {
    pub m_flags: u32,
    pub m_buffer_count: u32,
    pub m_parent_dir: page_dir_t,
    pub m_buffers: *mut heap_node_buffer_t,
    pub m_free_size: usize,
    pub m_used_size: usize,
}
#[test]
fn bindgen_test_layout_memory_allocator() {
    const UNINIT: ::std::mem::MaybeUninit<memory_allocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<memory_allocator>(),
        64usize,
        concat!("Size of: ", stringify!(memory_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<memory_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(memory_allocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_allocator),
            "::",
            stringify!(m_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_allocator),
            "::",
            stringify!(m_buffer_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_parent_dir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_allocator),
            "::",
            stringify!(m_parent_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_buffers) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_allocator),
            "::",
            stringify!(m_buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_free_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_allocator),
            "::",
            stringify!(m_free_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_used_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_allocator),
            "::",
            stringify!(m_used_size)
        )
    );
}
pub type memory_allocator_t = memory_allocator;
extern "C" {
    pub fn malloc_heap_init(
        allocator: *mut memory_allocator_t,
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc_heap_dump(allocator: *mut memory_allocator_t);
}
extern "C" {
    pub fn create_malloc_heap(
        size: usize,
        virtual_base: vaddr_t,
        flags: usize,
    ) -> *mut memory_allocator_t;
}
extern "C" {
    pub fn create_malloc_heap_ex(
        dir: *mut page_dir_t,
        size: usize,
        virtual_base: vaddr_t,
        flags: usize,
    ) -> *mut memory_allocator_t;
}
extern "C" {
    pub fn memory_allocate(
        allocator: *mut memory_allocator_t,
        bytes: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memory_sized_deallocate(
        allocator: *mut memory_allocator_t,
        addr: *mut ::std::os::raw::c_void,
        allocation_size: usize,
    );
}
extern "C" {
    pub fn memory_deallocate(allocator: *mut memory_allocator_t, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn memory_try_heap_expand(
        allocator: *mut memory_allocator_t,
        new_size: usize,
    ) -> ANIVA_STATUS;
}
extern "C" {
    pub fn quick_print_node_sizes(allocator: *mut memory_allocator_t);
}
extern "C" {
    pub fn memory_get_heapnode_at(buffer: *mut heap_node_buffer_t, index: u32) -> *mut heap_node_t;
}
extern "C" {
    pub fn init_kheap();
}
extern "C" {
    pub fn debug_kheap();
}
extern "C" {
    pub fn kmalloc(len: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kfree(addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn kheap_copy_main_allocator(alloc: *mut memory_allocator_t) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
